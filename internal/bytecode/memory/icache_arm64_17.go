//go:build !go1.18
// +build !go1.18

package memory

// icache 清理指令内容
// icache 清理指令内容
var (
	insPadding = []byte{
		0xEB, 0x07, 0x40, 0xF9, // # 	ldr   	x11, [sp, #8]
		0x2B, 0x75, 0x0b, 0xd5, // #	ic		ivau, x11
		0x6B, 0x01, 0x01, 0x91, // # 	add		x11, x11, #1<<6
		0x2B, 0x75, 0x0b, 0xd5, // #	ic		ivau, x11
		0x6B, 0x01, 0x01, 0x91, // # 	add		x11, x11, #1<<6
		0x2B, 0x75, 0x0b, 0xd5, // #	ic		ivau, x11
		0x6B, 0x01, 0x01, 0x91, // # 	add		x11, x11, #1<<6
		0x2B, 0x75, 0x0b, 0xd5, // #	ic		ivau, x11
	}

	// clearICacheIns 清除指令缓存指令
	// 新版mac使用 AARCH64 (arm64v8), 指令缓存命中率较高, 会出现patch成功但是使用缓存中原来的指令来执行，导致 mock 失败
	clearICacheIns = []byte{
		//0x60, 0x00, 0xa0, 0xd2,//# 	mov 	x1,  [size] // 8个指令 $ 1-4
		0xE0, 0x07, 0x40, 0xF9, // # 	ldr   	x0, [sp, #8] $ 5
		0x09, 0xe4, 0x7a, 0x92, // # 	and		x9, x0, #~((1<<6)-1) $ 6 cacheline align address
		0x0a, 0x14, 0x40, 0x92, // # 	and		x10, x0, #((1<<6)-1) $ 7 extend length by alignment
		0x2a, 0x00, 0x0a, 0x8b, // # 	add		x10, x1, x10 $ 8
		0x4a, 0x05, 0x00, 0xd1, // # 	sub		x10, x10, #1 $ 9
		0x0b, 0x00, 0x80, 0x92, // # 	mov		x11, #-1 $ 10
		0x6a, 0x19, 0x4a, 0xca, // # 	eor		x10, x11, x10, lsr #6 $ 11 compute cacheline counter
		0x9f, 0x3b, 0x03, 0xd5, // # 	dsb		ish $ 12
	}

	clearICacheIns1 = []byte{
		// 循环
		0x29, 0x75, 0x0b, 0xd5, // #	ic		ivau, x9 $ 13
		0x29, 0x01, 0x01, 0x91, // # 	add		x9, x9, #1<<6 $ 14
		0x4a, 0x05, 0x00, 0xb1, // # 	adds	x10, x10, #1 $ 15
		0xa1, 0xff, 0xff, 0x54, // # 	b.ne 	#0xfffffffffffffff4 $ 16
	}

	clearICacheIns2 = []byte{
		0x9f, 0x3b, 0x03, 0xd5, // # 	dsb		ish $ 20
		0xdf, 0x3f, 0x03, 0xd5, // # 	isb # 21
		0xc0, 0x03, 0x5f, 0xd6, // #	ret # 22
	}
)
